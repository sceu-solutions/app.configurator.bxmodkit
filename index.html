<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variant Configurator</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen p-6">
    <div class="max-w-7xl mx-auto">
        <!-- App Header -->
        <div class="bg-white rounded-2xl shadow-xl p-6 mb-8">
            <div class="text-center">
                <div class="text-2xl font-bold text-red-600 mb-2" style="color: #DC2626;">Schindler SA</div>
                <h1 class="text-3xl font-bold text-gray-800">BX Mod KIT - Light Configurator</h1>
            </div>
        </div>

        <!-- Upload Section -->
        <div id="upload-section" class="bg-white rounded-2xl shadow-xl p-8 mb-8 transition-all duration-500">
            
            <!-- Auto-loading status -->
            <div class="mb-6 p-4 bg-blue-50 rounded-lg">
                <div id="csv-status" class="text-sm text-gray-600">Auto-loading rules in progress...</div>
            </div>
            
            <!-- Manual upload fallback -->
            <div id="manual-upload-section" class="hidden">
                <div id="drop-zone" class="border-2 border-dashed border-indigo-300 rounded-lg p-12 text-center cursor-pointer bg-indigo-50 hover:bg-indigo-100 transition-colors">
                    <div class="text-indigo-600 text-6xl mb-4">üìÅ</div>
                    <p class="text-xl text-indigo-700 font-medium mb-2">Drag CSV file here</p>
                    <p class="text-indigo-600 mb-4">or click to select</p>
                    <input type="file" id="file-input" class="hidden" accept=".csv">
                    <button class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors">
                        Select File
                    </button>
                </div>
            </div>
            
            <div id="loading" class="hidden text-center py-8">
                <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                <p class="mt-2 text-gray-600">Loading...</p>
            </div>
        </div>

        <!-- Data Section -->
        <div id="data-section" class="hidden">
            <!-- Dynamic Layout Container -->
            <div id="layout-container" class="flex gap-6 min-h-screen">
                <!-- Left Column - Filters (40%) -->
                <div id="filters-column" class="w-[40%] flex flex-col">
                    <!-- Filter Controls -->
                    <div class="bg-white rounded-2xl shadow-xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-xl font-bold text-gray-800">üéõÔ∏è Rule Filters</h3>
                            <button id="reset-filters" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium text-sm">
                                üîÑ Reset
                            </button>
                        </div>
                        <div id="filter-container" class="space-y-4 pb-4">
                            <div class="text-gray-500 text-center py-8">
                                Loading filters...
                            </div>
                        </div>
                    </div>

                    <!-- Debug Panel - Hidden -->
                    <div id="debug-panel" class="hidden bg-gray-900 text-green-400 rounded-2xl shadow-xl p-4 mt-4 font-mono text-xs">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="text-sm font-bold text-white">üêõ Debug Console</h3>
                            <button id="clear-debug" class="px-2 py-1 bg-red-600 text-white rounded text-xs hover:bg-red-700">Clear</button>
                        </div>
                        <div id="debug-info" class="max-h-48 overflow-y-auto whitespace-pre-wrap bg-black p-2 rounded border"></div>
                        
                        <!-- Debug Status -->
                        <div class="mt-3 p-2 bg-gray-800 rounded">
                            <div class="text-white text-xs mb-1">Status:</div>
                            <div id="debug-status" class="text-yellow-400 text-xs"></div>
                        </div>
                        
                        <!-- Filter State -->
                        <div class="mt-2 p-2 bg-gray-800 rounded">
                            <div class="text-white text-xs mb-1">Active Filters:</div>
                            <div id="active-filters-debug" class="text-cyan-400 text-xs"></div>
                        </div>
                        
                        <!-- Available Filters -->
                        <div class="mt-2 p-2 bg-gray-800 rounded">
                            <div class="text-white text-xs mb-1">Available Filters:</div>
                            <div id="available-filters-debug" class="text-green-400 text-xs max-h-24 overflow-y-auto"></div>
                        </div>
                    </div>
                </div>

                <!-- Right Column - Results Table (60%) -->
                <div id="results-column" class="w-[60%] flex flex-col">
                    <!-- Controls -->
                    <div class="bg-white rounded-2xl shadow-xl p-4 mb-4">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-bold text-gray-800">üìã Materials List</h3>
                            <div class="flex items-center gap-4">
                                <button id="toggle-regola" class="px-3 py-1 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors text-sm">
                                    üìã Show Rules
                                </button>
                                <span id="row-count" class="text-gray-600 font-medium"></span>
                            </div>
                        </div>
                    </div>

                    <!-- Data Table -->
                    <div class="bg-white rounded-2xl shadow-xl overflow-hidden">
                        <div class="overflow-x-auto">
                            <table class="min-w-full">
                                <thead id="table-header" class="bg-indigo-600 text-white sticky top-0">
                                    <!-- Dynamic headers will be added here -->
                                </thead>
                                <tbody id="table-body" class="divide-y divide-gray-200">
                                    <!-- Dynamic rows will be added here -->
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Price Summary -->
                        <div id="price-summary" class="bg-green-50 px-6 py-4 border-t border-green-200">
                            <div class="flex items-center justify-between">
                                <div class="text-green-800 font-medium">
                                    <span id="visible-count">0</span> materials displayed
                                </div>
                                <div class="text-green-800 font-bold text-lg">
                                    Page Total: ‚Ç¨ <span id="total-price">0.00</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Pagination -->
                        <div class="bg-gray-50 px-6 py-4 flex items-center justify-between border-t">
                            <button id="prev-page" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-gray-400" disabled>
                                ‚Üê Previous
                            </button>
                            <span id="page-info" class="text-gray-600 font-medium"></span>
                            <button id="next-page" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-gray-400" disabled>
                                Next ‚Üí
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Device detection and layout setup
            const isMobile = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const layoutContainer = document.getElementById('layout-container');
            const filtersColumn = document.getElementById('filters-column');
            const resultsColumn = document.getElementById('results-column');
            
            // Apply layout based on device
            if (isMobile) {
                // Mobile layout: vertical stack
                layoutContainer.className = 'flex flex-col gap-6';
                filtersColumn.className = 'w-full flex flex-col order-1';
                resultsColumn.className = 'w-full flex flex-col order-2';
            } else {
                // Desktop layout: horizontal columns
                layoutContainer.className = 'flex gap-6 min-h-screen';
                filtersColumn.className = 'w-[40%] flex flex-col';
                resultsColumn.className = 'w-[60%] flex flex-col';
            }

            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const loadingElement = document.getElementById('loading');
            const dataSection = document.getElementById('data-section');
            const uploadSection = document.getElementById('upload-section');
            const tableHeader = document.getElementById('table-header');
            const tableBody = document.getElementById('table-body');
            const rowCount = document.getElementById('row-count');
            const prevPageBtn = document.getElementById('prev-page');
            const nextPageBtn = document.getElementById('next-page');
            const pageInfo = document.getElementById('page-info');
            const filterControls = document.getElementById('filter-controls');
            const resetFiltersBtn = document.getElementById('reset-filters');
            const debugPanel = document.getElementById('debug-panel');
            const debugInfo = document.getElementById('debug-info');
            const debugStatus = document.getElementById('debug-status');
            const activeFiltersDebug = document.getElementById('active-filters-debug');
            const availableFiltersDebug = document.getElementById('available-filters-debug');
            const clearDebugBtn = document.getElementById('clear-debug');
            const csvStatus = document.getElementById('csv-status');
            const manualUploadSection = document.getElementById('manual-upload-section');
            const toggleRegolaBtn = document.getElementById('toggle-regola');
            const visibleCount = document.getElementById('visible-count');
            const totalPrice = document.getElementById('total-price');

            let csvData = [];
            let headers = [];
            let currentPage = 1;
            let rowsPerPage = 30; // 30 rows per page
            let filteredData = []; // Start empty - will be populated only when filters are selected
            let ruleFields = {}; // Will store field names and their possible values
            let activeFilters = {}; // Will store currently selected filter values
            let availableFilters = {}; // Will store available filter values based on current selection
            let debugLog = [];
            let showRegolaColumn = false; // Toggle for REGOLA column visibility
            let startWithEmptyList = true; // New behavior: start with empty materials list
            // Price calculation will be done on visible rows only

            // Setup debug panel
            setupDebugPanel();
            
            // Handle window resize for responsive layout
            window.addEventListener('resize', function() {
                const newIsMobile = window.innerWidth <= 768;
                if (newIsMobile !== isMobile) {
                    location.reload(); // Simple solution: reload on layout change
                }
            });
            
            // Auto-load CSV on startup
            loadRulesAutomatically();

            // Handle drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                dropZone.classList.add('active');
            }

            function unhighlight() {
                dropZone.classList.remove('active');
            }

            dropZone.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFiles(files);
            }

            fileInput.addEventListener('change', function() {
                handleFiles(this.files);
            });



            function handleFiles(files) {
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
                        parseCSV(file);
                    } else {
                        alert('Please upload a valid CSV file.');
                    }
                }
            }

            // Auto-load function
            function loadRulesAutomatically() {
                csvStatus.textContent = 'Auto-loading rules in progress...';
                csvStatus.className = 'text-sm text-blue-600';
                
                fetch('regole-prodotto-WebApp-BX MOD KIT.csv')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`File not found: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(content => {
                        parseCSVContent(content);
                        csvStatus.textContent = '‚úÖ Rules loaded automatically from server successfully';
                        csvStatus.className = 'text-sm text-green-600';
                        showDataSection();
                    })
                    .catch(error => {
                        csvStatus.textContent = `‚ùå Auto-loading error: ${error.message}`;
                        csvStatus.className = 'text-sm text-red-600';
                        console.error('CSV loading error:', error);
                        
                        // Show manual upload fallback
                        manualUploadSection.classList.remove('hidden');
                        setupManualUpload();
                    });
            }

            function setupManualUpload() {
                dropZone.addEventListener('click', () => {
                    fileInput.click();
                });
            }

            function parseCSV(file) {
                loadingElement.classList.remove('hidden');
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    parseCSVContent(content);
                    showDataSection();
                };
                reader.readAsText(file);
            }

            function parseCSVContent(content) {
                const lines = content.split('\n').filter(line => line.trim() !== '');
                
                if (lines.length === 0) {
                    alert('The CSV file is empty.');
                    return;
                }

                // Parse headers
                headers = lines[0].split(';').map(header => header.trim());
                
                // Parse data
                csvData = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(';');
                    const row = {};
                    
                    headers.forEach((header, index) => {
                        row[header] = values[index] ? values[index].trim() : '';
                    });
                    
                    csvData.push(row);
                }

                // Don't populate filteredData initially - keep it empty until filters are selected
                addDebugMessage(`CSV loaded: ${csvData.length} rows, ${headers.length} columns`);
            }

            function showDataSection() {
                updateDebugStatus("Showing data section...");
                loadingElement.classList.add('hidden');
                uploadSection.classList.add('hidden'); // Hide upload section completely
                dataSection.classList.remove('hidden');
                
                createTable();
                setupEventListeners();
                updateRowCount();
                updatePagination();
                
                updateDebugStatus("Initializing filters...");
                
                // Auto-analyze rules after loading and create filters
                setTimeout(() => {
                    addDebugMessage("=== FILTER INITIALIZATION START ===");
                    addDebugMessage(`CSV Data: ${csvData.length} rows loaded`);
                    addDebugMessage(`Headers: ${headers.join(', ')}`);
                    
                    parseRules();
                    // Removed parseTypeField() - was causing initialization issues
                    
                    addDebugMessage(`RuleFields after parsing: ${Object.keys(ruleFields).length} fields`);
                    Object.keys(ruleFields).forEach(field => {
                        addDebugMessage(`  ${field}: [${ruleFields[field].join(', ')}]`);
                    });
                    
                    // Initialize filters with empty materials list
                    activeFilters = {};
                    filteredData = []; // Start empty - materials will appear only when filters are selected
                    
                    // Ensure table displays empty state immediately
                    displayTable();
                    
                    addDebugMessage("Updating available filters...");
                    updateAvailableFilters();
                    
                    addDebugMessage("Creating filter interface...");
                    createFilters();
                    
                    updateDebugStatus("Filters loaded!");
                    addDebugMessage("=== FILTER INITIALIZATION END ===");
                    
                    updateActiveFiltersDisplay();
                    updateAvailableFiltersDisplay();
                }, 500);
            }
            
            function setupDebugPanel() {
                clearDebugBtn.addEventListener('click', () => {
                    debugLog = [];
                    updateDebugPanel();
                });
                
                updateDebugStatus("Initializing...");
                updateActiveFiltersDisplay();
                updateAvailableFiltersDisplay();
            }

            function addDebugMessage(message, type = "info") {
                const timestamp = new Date().toLocaleTimeString();
                debugLog.push({ message, type, timestamp });
                console.log(`[${type.toUpperCase()}] ${message}`);
                updateDebugPanel();
            }
            
            function updateDebugStatus(status) {
                if (debugStatus) {
                    debugStatus.textContent = status;
                }
            }
            
            function updateActiveFiltersDisplay() {
                if (activeFiltersDebug) {
                    if (Object.keys(activeFilters).length === 0) {
                        activeFiltersDebug.textContent = "No active filters";
                    } else {
                        activeFiltersDebug.textContent = JSON.stringify(activeFilters, null, 2);
                    }
                }
            }
            
            function updateAvailableFiltersDisplay() {
                if (availableFiltersDebug) {
                    const summary = {};
                    Object.keys(availableFilters).forEach(field => {
                        summary[field] = `${availableFilters[field].length} values`;
                    });
                    availableFiltersDebug.textContent = JSON.stringify(summary, null, 2);
                }
            }

            function updateDebugPanel() {
                if (debugInfo) {
                    debugInfo.textContent = debugLog.slice(-50).map(log => 
                        `[${log.timestamp}] ${log.message}`
                    ).join('\n');
                    debugInfo.scrollTop = debugInfo.scrollHeight;
                }
            }

            function createTable() {
                // Create table headers
                tableHeader.innerHTML = '';
                const headerRow = document.createElement('tr');
                
                // No selection checkbox needed
                
                headers.forEach(header => {
                    // Skip TYPE column and conditionally show REGOLA
                    if (header.toLowerCase() === 'type') return;
                    if (header.toLowerCase() === 'regola' && !showRegolaColumn) return;
                    
                    const th = document.createElement('th');
                    th.className = 'py-3 px-4 text-left font-semibold';
                    
                    // Special formatting for price column
                    if (header.toLowerCase().includes('prezzo') || header.toLowerCase().includes('price')) {
                        th.textContent = header + ' (‚Ç¨)';
                        th.className += ' text-right';
                    } else {
                        th.textContent = header;
                    }
                    
                    headerRow.appendChild(th);
                });
                
                tableHeader.appendChild(headerRow);
                
                // Don't display data initially - table will be empty until filters are selected
            }

            function displayTable() {
                tableBody.innerHTML = '';
                
                // Show empty state message when no filters are selected or no results
                if (filteredData.length === 0) {
                    const emptyRow = document.createElement('tr');
                    const emptyCell = document.createElement('td');
                    emptyCell.colSpan = headers.filter(h => {
                        if (h.toLowerCase() === 'type') return false;
                        if (h.toLowerCase() === 'regola' && !showRegolaColumn) return false;
                        return true;
                    }).length;
                    emptyCell.className = 'py-12 px-4 text-center text-gray-500';
                    
                    if (Object.keys(activeFilters).length === 0) {
                        emptyCell.innerHTML = `
                            <div class="text-lg mb-2">üéØ</div>
                            <div class="font-medium">Select filter criteria to view materials</div>
                            <div class="text-sm mt-1">Use the filters on the left to find matching materials</div>
                        `;
                    } else {
                        emptyCell.innerHTML = `
                            <div class="text-lg mb-2">üîç</div>
                            <div class="font-medium">No materials match the selected criteria</div>
                            <div class="text-sm mt-1">Try adjusting your filter selection</div>
                        `;
                    }
                    
                    emptyRow.appendChild(emptyCell);
                    tableBody.appendChild(emptyRow);
                    updatePriceCalculation();
                    return;
                }
                
                const startIndex = (currentPage - 1) * rowsPerPage;
                const endIndex = Math.min(startIndex + rowsPerPage, filteredData.length);
                
                for (let i = startIndex; i < endIndex; i++) {
                    const row = filteredData[i];
                    const rowId = `row_${startIndex + i}`;
                    const tr = document.createElement('tr');
                    tr.className = i % 2 === 0 ? 'bg-gray-50' : 'bg-white';
                    tr.setAttribute('data-row-id', rowId);
                    
                    // No selection checkbox needed
                    
                    headers.forEach(header => {
                        // Skip TYPE column and conditionally show REGOLA
                        if (header.toLowerCase() === 'type') return;
                        if (header.toLowerCase() === 'regola' && !showRegolaColumn) return;
                        
                        const td = document.createElement('td');
                        td.className = 'py-2 px-4 text-sm';
                        
                        // Special formatting for price column
                        if (header.toLowerCase().includes('prezzo') || header.toLowerCase().includes('price')) {
                            const priceValue = row[header] || '';
                            if (priceValue && !isNaN(parseFloat(priceValue.replace(',', '.')))) {
                                // Format as currency
                                const numericPrice = parseFloat(priceValue.replace(',', '.'));
                                td.textContent = numericPrice.toLocaleString('it-IT', {
                                    minimumFractionDigits: 2,
                                    maximumFractionDigits: 2
                                });
                                td.className += ' text-right font-medium text-green-700';
                            } else {
                                td.textContent = priceValue;
                                td.className += ' text-right';
                            }
                        } else if (header.toLowerCase() === 'regola') {
                            // Special formatting for REGOLA column - make it smaller and wrap
                            td.className += ' text-xs text-gray-600 max-w-xs break-words';
                            td.textContent = row[header] || '';
                        } else {
                            td.textContent = row[header] || '';
                        }
                        
                        tr.appendChild(td);
                    });
                    
                    tableBody.appendChild(tr);
                }
                
                updatePriceCalculation();
            }

            function setupEventListeners() {
                // Pagination
                prevPageBtn.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        displayTable();
                        updatePagination();
                    }
                });

                nextPageBtn.addEventListener('click', () => {
                    const totalPages = Math.ceil(filteredData.length / rowsPerPage);
                    if (currentPage < totalPages) {
                        currentPage++;
                        displayTable();
                        updatePagination();
                    }
                });

                // Reset filters button
                resetFiltersBtn.addEventListener('click', () => {
                    addDebugMessage("=== RESET FILTERS ===");
                    activeFilters = {};
                    filteredData = []; // Reset to empty list
                    currentPage = 1;
                    
                    updateActiveFiltersDisplay();
                    updateAvailableFilters();
                    updateAvailableFiltersDisplay();
                    
                    displayTable();
                    updateRowCount();
                    updatePagination();
                    createFilters(); // Recreate filters to reset selections
                    
                    addDebugMessage("Reset completed");
                });

                // Toggle REGOLA column visibility
                toggleRegolaBtn.addEventListener('click', () => {
                    showRegolaColumn = !showRegolaColumn;
                    toggleRegolaBtn.textContent = showRegolaColumn ? 'üìã Hide Rules' : 'üìã Show Rules';
                    createTable(); // Recreate table with/without REGOLA column
                });
            }

            function updateRowCount() {
                if (filteredData.length === 0 && Object.keys(activeFilters).length === 0) {
                    rowCount.textContent = `Select filters to view materials`;
                } else {
                    rowCount.textContent = `${filteredData.length} materials`;
                }
            }

            function updatePagination() {
                const totalPages = Math.ceil(filteredData.length / rowsPerPage);
                pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
                
                prevPageBtn.disabled = currentPage === 1;
                nextPageBtn.disabled = currentPage === totalPages || totalPages === 0;
            }

            // Original parseRules function from version 13
            function parseRules(regolaColumn = 'REGOLA') {
                addDebugMessage("Starting rule analysis...");
                ruleFields = {};
                
                // Find the correct column name (case insensitive)
                const actualColumn = headers.find(h => h.toLowerCase() === regolaColumn.toLowerCase()) || regolaColumn;
                
                // Process each row's REGOLA column
                let ruleCount = 0;
                let fieldCount = 0;
                let patternFound = 0;
                
                csvData.forEach((row, index) => {
                    const ruleText = row[actualColumn];
                    if (!ruleText) return;
                    
                    ruleCount++;
                    if (ruleCount <= 5) {
                        addDebugMessage(`Analyzing rule #${index+1}: "${ruleText}"`);
                    }
                    
                    // First, handle square brackets by removing them for parsing
                    let cleanRuleText = ruleText;
                    const hasBrackets = ruleText.includes('[') && ruleText.includes(']');
                    
                    if (hasBrackets) {
                        cleanRuleText = ruleText.replace(/[\[\]]/g, '');
                        if (ruleCount <= 5) {
                            addDebugMessage(`  Removed square brackets for analysis: "${cleanRuleText}"`);
                        }
                    }
                    
                    // Try to find field=value patterns with flexible spacing around =
                    const fieldRegex = /(\w+)\s*=\s*([^=]+?)(?=\s+\w+\s*=|$)/g;
                    let match;
                    let foundInThisRule = false;
                    
                    while ((match = fieldRegex.exec(cleanRuleText)) !== null) {
                        foundInThisRule = true;
                        patternFound++;
                        
                        const field = match[1].trim();
                        const valuesPart = match[2].trim();
                        
                        if (ruleCount <= 5) {
                            addDebugMessage(`  Field found: "${field}" with expression: "${valuesPart}"`);
                        }
                        
                        // Initialize field if not exists
                        if (!ruleFields[field]) {
                            ruleFields[field] = new Set();
                            fieldCount++;
                        }
                        
                        // Extract values, properly handling logical operators and parentheses
                        extractValues(field, valuesPart, ruleCount);
                    }
                    
                    if (!foundInThisRule && ruleCount <= 10) {
                        addDebugMessage(`  No field=value pattern found in rule #${index+1}`, "warning");
                    }
                });
                
                // Convert Sets to Arrays
                Object.keys(ruleFields).forEach(field => {
                    ruleFields[field] = Array.from(ruleFields[field]).sort();
                });
                
                addDebugMessage(`Analysis completed. Found ${fieldCount} fields in ${ruleCount} rules. Patterns recognized: ${patternFound}`);
                addDebugMessage("Extracted fields and values:");
                Object.keys(ruleFields).forEach(field => {
                    addDebugMessage(`  ${field}: ${ruleFields[field].join(', ')}`);
                });
                
                updateDebugPanel();
            }

            // parseTypeField function removed - was causing initialization issues

            function extractValues(field, valuesPart, ruleCount) {
                // Remove logical operators (AND, OR) only at the end - they separate different field=value pairs
                let cleanValues = valuesPart.replace(/\s+(AND|OR)\s*$/i, '').trim();
                
                if (ruleCount <= 5) {
                    addDebugMessage(`    Processing values for ${field}: "${cleanValues}"`);
                }
                
                // Handle parentheses for multiple values
                if (cleanValues.startsWith('(')) {
                    // Find the matching closing parenthesis
                    let parenCount = 0;
                    let endIndex = -1;
                    
                    for (let i = 0; i < cleanValues.length; i++) {
                        if (cleanValues[i] === '(') parenCount++;
                        if (cleanValues[i] === ')') {
                            parenCount--;
                            if (parenCount === 0) {
                                endIndex = i;
                                break;
                            }
                        }
                    }
                    
                    if (endIndex !== -1) {
                        // Extract only the content within the first set of parentheses
                        const innerValues = cleanValues.slice(1, endIndex);
                        const values = innerValues.split(',').map(v => v.trim()).filter(v => v);
                        
                        values.forEach(value => {
                            ruleFields[field].add(value);
                            if (ruleCount <= 5) {
                                addDebugMessage(`      Aggiunto valore: "${value}"`);
                            }
                        });
                        
                        // Check if there's more content after the closing parenthesis (like "and DOOR_VOLTAGE (80VDC")
                        const remainingText = cleanValues.slice(endIndex + 1).trim();
                        if (remainingText) {
                            const nextFieldMatch = remainingText.match(/^\s*and\s+(\w+)\s*\(([^)]+)\)/i);
                            if (nextFieldMatch) {
                                const nextField = nextFieldMatch[1].trim();
                                const nextValue = nextFieldMatch[2].trim();
                                if (!ruleFields[nextField]) {
                                    ruleFields[nextField] = new Set();
                                }
                                ruleFields[nextField].add(nextValue);
                                if (ruleCount <= 5) {
                                    addDebugMessage(`      Trovato campo aggiuntivo: "${nextField}" con valore: "${nextValue}"`);
                                }
                            }
                        }
                    } else {
                        // Malformed parentheses, treat as single value
                        ruleFields[field].add(cleanValues);
                        if (ruleCount <= 5) {
                            addDebugMessage(`      Aggiunto valore con parentesi malformate: "${cleanValues}"`);
                        }
                    }
                } else {
                    // Single value without parentheses
                    ruleFields[field].add(cleanValues);
                    if (ruleCount <= 5) {
                        addDebugMessage(`      Aggiunto valore singolo: "${cleanValues}"`);
                    }
                }
            }

            function createFilters() {
                addDebugMessage("=== CREATING FILTERS ===");
                
                if (Object.keys(ruleFields).length === 0) {
                    addDebugMessage("ERROR: No fields found in ruleFields!", "error");
                    return;
                }

                const container = document.getElementById('filter-container');
                container.innerHTML = '';
                
                addDebugMessage(`Creating filters for ${Object.keys(ruleFields).length} fields`);

                Object.keys(ruleFields).forEach(field => {
                    addDebugMessage(`Creating filter for field: ${field}`);
                    
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'bg-gray-50 p-4 rounded-lg border';
                    
                    const fieldTitle = document.createElement('h4');
                    fieldTitle.className = 'font-semibold text-gray-800 mb-3';
                    fieldTitle.textContent = field;
                    fieldDiv.appendChild(fieldTitle);
                    
                    const valuesDiv = document.createElement('div');
                    valuesDiv.className = 'flex flex-wrap gap-2';
                    
                    const availableValues = availableFilters[field] || [];
                    const allValues = ruleFields[field] || [];
                    
                    addDebugMessage(`  Field ${field}: ${allValues.length} total values, ${availableValues.length} available`);
                    addDebugMessage(`  Total values: [${allValues.join(', ')}]`);
                    addDebugMessage(`  Available values: [${availableValues.join(', ')}]`);
                    
                    allValues.forEach(value => {
                        const button = document.createElement('button');
                        const isSelected = activeFilters[field] === value;
                        const isAvailable = availableValues.includes(value);
                        
                        addDebugMessage(`    Value "${value}": selected=${isSelected}, available=${isAvailable}`);
                        
                        if (isSelected) {
                            button.className = 'px-3 py-1 bg-indigo-600 text-white rounded-full text-sm font-medium';
                        } else if (isAvailable) {
                            button.className = 'px-3 py-1 bg-white text-gray-700 border border-gray-300 rounded-full text-sm hover:bg-gray-50 cursor-pointer';
                        } else {
                            button.className = 'px-3 py-1 bg-gray-200 text-gray-400 border border-gray-200 rounded-full text-sm cursor-not-allowed opacity-50';
                            button.disabled = true;
                        }
                        
                        button.textContent = value;
                        
                        if (!button.disabled) {
                            button.addEventListener('click', () => {
                                addDebugMessage(`Click on ${field}=${value}`);
                                
                                if (activeFilters[field] === value) {
                                    // Deselect
                                    addDebugMessage(`Deselecting ${field}=${value}`);
                                    delete activeFilters[field];
                                } else {
                                    // Select
                                    addDebugMessage(`Selecting ${field}=${value}`);
                                    activeFilters[field] = value;
                                }
                                
                                updateActiveFiltersDisplay();
                                applyFilters();
                                updateAvailableFilters();
                                updateAvailableFiltersDisplay();
                                createFilters(); // Recreate to update available options
                            });
                        }
                        
                        valuesDiv.appendChild(button);
                    });
                    
                    fieldDiv.appendChild(valuesDiv);
                    container.appendChild(fieldDiv);
                });
                
                addDebugMessage("=== END FILTER CREATION ===");
            }

            function updateAvailableFilters() {
                addDebugMessage("=== UPDATING AVAILABLE FILTERS ===");
                availableFilters = {};
                
                addDebugMessage(`Current active filters: ${JSON.stringify(activeFilters)}`);
                
                // For each field, calculate which values are available based on current filter selection
                Object.keys(ruleFields).forEach(field => {
                    addDebugMessage(`Calculating available values for field: ${field}`);
                    availableFilters[field] = new Set();
                    
                    let matchingRows = 0;
                    let totalRowsChecked = 0;
                    
                    // Check each row to see what values are available for this field
                    csvData.forEach((row, index) => {
                        totalRowsChecked++;
                        
                        // Create a filter set excluding the current field we're calculating
                        const otherActiveFilters = { ...activeFilters };
                        delete otherActiveFilters[field];
                        
                        // Only log first few rows to avoid spam
                        if (index < 3) {
                            addDebugMessage(`  Row ${index+1}: Checking compatibility with filters: ${JSON.stringify(otherActiveFilters)}`);
                        }
                        
                        // Check if this row matches all OTHER active filters
                        if (matchesAllFilters(row, otherActiveFilters)) {
                            matchingRows++;
                            
                            // Extract values for this field from the REGOLA column
                            const ruleText = row[headers.find(h => h.toLowerCase() === 'regola')] || '';
                            if (ruleText && ruleText.trim() !== '') {
                                const fieldValues = extractFieldValuesFromRule(ruleText, field);
                                if (index < 3) {
                                    addDebugMessage(`    Row ${index+1} compatible. Extracted values for ${field}: [${fieldValues.join(', ')}]`);
                                }
                                
                                fieldValues.forEach(value => {
                                    if (value && value.trim()) {
                                        availableFilters[field].add(value.trim());
                                        if (index < 3) {
                                            addDebugMessage(`      Added available value: "${value.trim()}"`);
                                        }
                                    }
                                });
                            } else if (index < 3) {
                                addDebugMessage(`    Row ${index+1} compatible but no valid rule`);
                            }
                        } else if (index < 3) {
                            addDebugMessage(`    Row ${index+1} NOT compatible with active filters`);
                        }
                    });
                    
                    availableFilters[field] = Array.from(availableFilters[field]).sort();
                    addDebugMessage(`  Field ${field}: ${totalRowsChecked} rows checked, ${matchingRows} compatible rows, ${availableFilters[field].length} available values`);
                    addDebugMessage(`  Available values: [${availableFilters[field].join(', ')}]`);
                    
                    // If no filters are active, all values should be available (but materials list stays empty)
                    if (Object.keys(activeFilters).length === 0) {
                        availableFilters[field] = [...ruleFields[field]];
                        addDebugMessage(`  No active filters - all values available for ${field}`);
                    }
                });
                
                addDebugMessage("=== END UPDATING AVAILABLE FILTERS ===");
            }

            function extractFieldValuesFromRule(ruleText, targetField) {
                const values = [];
                let cleanRuleText = ruleText.replace(/[\[\]]/g, '');
                
                const fieldRegex = /(\w+)\s*=\s*([^=]+?)(?=\s+\w+\s*=|$)/g;
                let match;
                
                while ((match = fieldRegex.exec(cleanRuleText)) !== null) {
                    const field = match[1].trim();
                    const valuesPart = match[2].trim();
                    
                    if (field === targetField) {
                        // Remove logical operators (AND, OR) only at the end
                        let cleanValues = valuesPart.replace(/\s+(AND|OR)\s*$/i, '').trim();
                        
                        if (cleanValues.startsWith('(')) {
                            // Find the matching closing parenthesis
                            let parenCount = 0;
                            let endIndex = -1;
                            
                            for (let i = 0; i < cleanValues.length; i++) {
                                if (cleanValues[i] === '(') parenCount++;
                                if (cleanValues[i] === ')') {
                                    parenCount--;
                                    if (parenCount === 0) {
                                        endIndex = i;
                                        break;
                                    }
                                }
                            }
                            
                            if (endIndex !== -1) {
                                // Extract only the content within the first set of parentheses
                                const innerValues = cleanValues.slice(1, endIndex);
                                const multiValues = innerValues.split(',').map(v => v.trim()).filter(v => v);
                                values.push(...multiValues);
                            }
                        } else {
                            values.push(cleanValues);
                        }
                    }
                }
                
                // Also check for fields that appear after "and" in truncated patterns
                const truncatedFieldRegex = /\)\s+and\s+(\w+)\s*\(([^)]+)\)/gi;
                let truncatedMatch;
                while ((truncatedMatch = truncatedFieldRegex.exec(cleanRuleText)) !== null) {
                    const field = truncatedMatch[1].trim();
                    const value = truncatedMatch[2].trim();
                    
                    if (field === targetField) {
                        values.push(value);
                    }
                }
                
                return values;
            }

            function matchesAllFilters(row, filters) {
                if (Object.keys(filters).length === 0) {
                    return true;
                }
                
                for (const [field, value] of Object.entries(filters)) {
                    // For ALL fields, check ONLY in REGOLA column
                    const ruleText = row[headers.find(h => h.toLowerCase() === 'regola')] || '';
                    const matches = matchesRuleFilter(ruleText, field, value);
                    
                    if (!matches) {
                        return false;
                    }
                }
                
                return true;
            }

            function matchesRuleFilter(ruleText, field, value) {
                let cleanRule = ruleText.replace(/[\[\]]/g, '').trim();
                
                // First check normal field=value patterns
                const fieldRegex = new RegExp(`${field}\\s*=\\s*([^=]+?)(?=\\s+\\w+\\s*=|$)`, 'g');
                let match = fieldRegex.exec(cleanRule);
                
                if (match) {
                    // Remove logical operators (AND, OR) only at the end
                    const valuesPart = match[1].trim().replace(/\s+(AND|OR)\s*$/i, '').trim();
                    
                    if (valuesPart.startsWith('(')) {
                        // Find the matching closing parenthesis
                        let parenCount = 0;
                        let endIndex = -1;
                        
                        for (let i = 0; i < valuesPart.length; i++) {
                            if (valuesPart[i] === '(') parenCount++;
                            if (valuesPart[i] === ')') {
                                parenCount--;
                                if (parenCount === 0) {
                                    endIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        if (endIndex !== -1) {
                            // Extract only the content within the first set of parentheses
                            const innerValues = valuesPart.slice(1, endIndex);
                            const multiValues = innerValues.split(',').map(v => v.trim()).filter(v => v);
                            return multiValues.includes(value);
                        }
                    } else {
                        return valuesPart === value;
                    }
                }
                
                // Also check for fields that appear after "and" in truncated patterns
                const truncatedFieldRegex = new RegExp(`\\)\\s+and\\s+${field}\\s*\\(([^)]+)\\)`, 'gi');
                let truncatedMatch = truncatedFieldRegex.exec(cleanRule);
                if (truncatedMatch) {
                    const truncatedValue = truncatedMatch[1].trim();
                    return truncatedValue === value;
                }
                
                return false;
            }

            function applyFilters() {
                if (Object.keys(activeFilters).length === 0) {
                    // No filters selected - keep materials list empty
                    filteredData = [];
                    addDebugMessage("No filters selected - materials list remains empty");
                } else {
                    // Apply filters and show matching materials
                    filteredData = csvData.filter(row => {
                        return matchesAllFilters(row, activeFilters);
                    });
                    addDebugMessage(`Filters applied. ${filteredData.length} matching materials found.`);
                }
                
                currentPage = 1;
                displayTable();
                updateRowCount();
                updatePagination();
            }

            // Price calculation functions removed - now calculated automatically on visible rows

            function updatePriceCalculation() {
                let totalAmount = 0;
                let visibleRowCount = 0;
                
                // Find price column
                const priceColumn = headers.find(h => 
                    h.toLowerCase().includes('prezzo') || h.toLowerCase().includes('price')
                );
                
                if (priceColumn) {
                    const startIndex = (currentPage - 1) * rowsPerPage;
                    const endIndex = Math.min(startIndex + rowsPerPage, filteredData.length);
                    
                    for (let i = startIndex; i < endIndex; i++) {
                        const rowData = filteredData[i];
                        const priceValue = rowData[priceColumn] || '';
                        
                        if (priceValue && !isNaN(parseFloat(priceValue.replace(',', '.')))) {
                            const numericPrice = parseFloat(priceValue.replace(',', '.'));
                            totalAmount += numericPrice;
                        }
                        visibleRowCount++;
                    }
                }
                
                // Update display
                visibleCount.textContent = visibleRowCount;
                totalPrice.textContent = totalAmount.toLocaleString('it-IT', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'97a36ff29528edb3',t:'MTc1NzA1MTMwMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
