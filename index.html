<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variant Configurator</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen p-6">
    <div class="max-w-7xl mx-auto">
        <!-- App Header -->
        <div class="bg-white rounded-2xl shadow-xl p-6 mb-8">
            <div class="text-center">
                <div class="text-2xl font-bold text-red-600 mb-2" style="color: #DC2626;">Schindler SA</div>
                <h1 class="text-3xl font-bold text-gray-800">BX Mod KIT - Light configurator</h1>
            </div>
        </div>

        <!-- Upload Section -->
        <div id="upload-section" class="bg-white rounded-2xl shadow-xl p-8 mb-8 transition-all duration-500">
            
            <!-- Auto-loading status -->
            <div class="mb-6 p-4 bg-blue-50 rounded-lg">
                <div id="csv-status" class="text-sm text-gray-600">Caricamento automatico regole in corso...</div>
            </div>
            
            <!-- Manual upload fallback -->
            <div id="manual-upload-section" class="hidden">
                <div id="drop-zone" class="border-2 border-dashed border-indigo-300 rounded-lg p-12 text-center cursor-pointer bg-indigo-50 hover:bg-indigo-100 transition-colors">
                    <div class="text-indigo-600 text-6xl mb-4">üìÅ</div>
                    <p class="text-xl text-indigo-700 font-medium mb-2">Trascina il file CSV qui</p>
                    <p class="text-indigo-600 mb-4">oppure clicca per selezionare</p>
                    <input type="file" id="file-input" class="hidden" accept=".csv">
                    <button class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors">
                        Seleziona File
                    </button>
                </div>
            </div>
            
            <div id="loading" class="hidden text-center py-8">
                <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                <p class="mt-2 text-gray-600">Caricamento in corso...</p>
            </div>
        </div>

        <!-- Data Section -->
        <div id="data-section" class="hidden">
            <!-- Controls -->
            <div class="bg-white rounded-2xl shadow-xl p-6 mb-8">
                <div class="flex flex-wrap items-center justify-between gap-4">
                    <div class="flex items-center gap-4">
                        <button id="reset-filters" class="px-6 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium">
                            üîÑ Reset Filtri
                        </button>
                    </div>
                    <div class="flex items-center gap-4">
                        <span id="row-count" class="text-gray-600 font-medium"></span>
                    </div>
                </div>
            </div>

            <!-- Filter Controls -->
            <div id="filter-controls" class="bg-white rounded-2xl shadow-xl p-6 mb-8">
                <h3 class="text-xl font-bold text-gray-800 mb-4">üéõÔ∏è Filtri Regole</h3>
                <div id="filter-container" class="space-y-4">
                    <div class="text-gray-500 text-center py-8">
                        Caricamento filtri in corso...
                    </div>
                </div>
            </div>

            <!-- Debug Panel -->
            <div id="debug-panel" class="bg-gray-900 text-green-400 rounded-2xl shadow-xl p-6 mb-8 hidden font-mono text-sm" style="display: none;">
                <h3 class="text-lg font-bold mb-4 text-white">üêõ Debug Information</h3>
                <div id="debug-info" class="max-h-64 overflow-y-auto whitespace-pre-wrap"></div>
            </div>

            <!-- Data Table -->
            <div class="bg-white rounded-2xl shadow-xl overflow-hidden">
                <div class="overflow-x-auto">
                    <table class="min-w-full">
                        <thead id="table-header" class="bg-indigo-600 text-white">
                            <!-- Dynamic headers will be added here -->
                        </thead>
                        <tbody id="table-body" class="divide-y divide-gray-200">
                            <!-- Dynamic rows will be added here -->
                        </tbody>
                    </table>
                </div>
                
                <!-- Pagination -->
                <div class="bg-gray-50 px-6 py-4 flex items-center justify-between border-t">
                    <button id="prev-page" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-gray-400" disabled>
                        ‚Üê Precedente
                    </button>
                    <span id="page-info" class="text-gray-600 font-medium"></span>
                    <button id="next-page" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-gray-400" disabled>
                        Successiva ‚Üí
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const loadingElement = document.getElementById('loading');
            const dataSection = document.getElementById('data-section');
            const uploadSection = document.getElementById('upload-section');
            const tableHeader = document.getElementById('table-header');
            const tableBody = document.getElementById('table-body');
            const rowCount = document.getElementById('row-count');
            const prevPageBtn = document.getElementById('prev-page');
            const nextPageBtn = document.getElementById('next-page');
            const pageInfo = document.getElementById('page-info');
            const filterControls = document.getElementById('filter-controls');
            const resetFiltersBtn = document.getElementById('reset-filters');
            const debugPanel = document.getElementById('debug-panel');
            const debugInfo = document.getElementById('debug-info');
            const csvStatus = document.getElementById('csv-status');
            const manualUploadSection = document.getElementById('manual-upload-section');

            let csvData = [];
            let headers = [];
            let currentPage = 1;
            let rowsPerPage = 30; // 30 rows per page
            let filteredData = [];
            let ruleFields = {}; // Will store field names and their possible values
            let activeFilters = {}; // Will store currently selected filter values
            let availableFilters = {}; // Will store available filter values based on current selection
            let debugLog = [];

            // Auto-load CSV on startup
            loadRulesAutomatically();

            // Handle drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                dropZone.classList.add('active');
            }

            function unhighlight() {
                dropZone.classList.remove('active');
            }

            dropZone.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFiles(files);
            }

            fileInput.addEventListener('change', function() {
                handleFiles(this.files);
            });



            function handleFiles(files) {
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
                        parseCSV(file);
                    } else {
                        alert('Per favore carica un file CSV valido.');
                    }
                }
            }

            // Auto-load function
            function loadRulesAutomatically() {
                csvStatus.textContent = 'Caricamento automatico regole in corso...';
                csvStatus.className = 'text-sm text-blue-600';
                
                fetch('regole-prodotto-WebApp-BX MOD KIT.csv')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`File non trovato: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(content => {
                        parseCSVContent(content);
                        csvStatus.textContent = '‚úÖ Regole caricate automaticamente con successo dal server';
                        csvStatus.className = 'text-sm text-green-600';
                        showDataSection();
                    })
                    .catch(error => {
                        csvStatus.textContent = `‚ùå Errore nel caricamento automatico: ${error.message}`;
                        csvStatus.className = 'text-sm text-red-600';
                        console.error('Errore caricamento CSV:', error);
                        
                        // Show manual upload fallback
                        manualUploadSection.classList.remove('hidden');
                        setupManualUpload();
                    });
            }

            function setupManualUpload() {
                dropZone.addEventListener('click', () => {
                    fileInput.click();
                });
            }

            function parseCSV(file) {
                loadingElement.classList.remove('hidden');
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    parseCSVContent(content);
                    showDataSection();
                };
                reader.readAsText(file);
            }

            function parseCSVContent(content) {
                const lines = content.split('\n').filter(line => line.trim() !== '');
                
                if (lines.length === 0) {
                    alert('Il file CSV √® vuoto.');
                    return;
                }

                // Parse headers
                headers = lines[0].split(';').map(header => header.trim());
                
                // Parse data
                csvData = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(';');
                    const row = {};
                    
                    headers.forEach((header, index) => {
                        row[header] = values[index] ? values[index].trim() : '';
                    });
                    
                    csvData.push(row);
                }

                filteredData = [...csvData];
                addDebugMessage(`CSV caricato: ${csvData.length} righe, ${headers.length} colonne`);
            }

            function showDataSection() {
                loadingElement.classList.add('hidden');
                uploadSection.classList.add('hidden'); // Hide upload section completely
                dataSection.classList.remove('hidden');
                
                createTable();
                setupEventListeners();
                updateRowCount();
                updatePagination();
                
                // Auto-analyze rules after loading
                parseRules();
                createFilters();
            }
            
            function addDebugMessage(message, type = "info") {
                const timestamp = new Date().toLocaleTimeString();
                debugLog.push({ message, type, timestamp });
                console.log(`[${type.toUpperCase()}] ${message}`);
                updateDebugPanel();
            }

            function updateDebugPanel() {
                if (debugInfo) {
                    debugInfo.textContent = debugLog.slice(-50).map(log => 
                        `[${log.timestamp}] ${log.message}`
                    ).join('\n');
                    debugInfo.scrollTop = debugInfo.scrollHeight;
                }
            }

            function createTable() {
                // Create table headers
                tableHeader.innerHTML = '';
                const headerRow = document.createElement('tr');
                
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = 'py-3 px-4 text-left font-semibold';
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                
                tableHeader.appendChild(headerRow);
                
                // Display initial data
                displayTable();
            }

            function displayTable() {
                tableBody.innerHTML = '';
                
                const startIndex = (currentPage - 1) * rowsPerPage;
                const endIndex = Math.min(startIndex + rowsPerPage, filteredData.length);
                
                for (let i = startIndex; i < endIndex; i++) {
                    const row = filteredData[i];
                    const tr = document.createElement('tr');
                    tr.className = i % 2 === 0 ? 'bg-gray-50' : 'bg-white';
                    
                    headers.forEach(header => {
                        const td = document.createElement('td');
                        td.className = 'py-2 px-4 text-sm';
                        td.textContent = row[header] || '';
                        tr.appendChild(td);
                    });
                    
                    tableBody.appendChild(tr);
                }
            }

            function setupEventListeners() {
                // Pagination
                prevPageBtn.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        displayTable();
                        updatePagination();
                    }
                });

                nextPageBtn.addEventListener('click', () => {
                    const totalPages = Math.ceil(filteredData.length / rowsPerPage);
                    if (currentPage < totalPages) {
                        currentPage++;
                        displayTable();
                        updatePagination();
                    }
                });

                // Reset filters button
                resetFiltersBtn.addEventListener('click', () => {
                    activeFilters = {};
                    filteredData = [...csvData];
                    currentPage = 1;
                    displayTable();
                    updateRowCount();
                    updatePagination();
                    createFilters(); // Recreate filters to reset selections
                });
            }

            function updateRowCount() {
                rowCount.textContent = `${filteredData.length} righe`;
            }

            function updatePagination() {
                const totalPages = Math.ceil(filteredData.length / rowsPerPage);
                pageInfo.textContent = `Pagina ${currentPage} di ${totalPages}`;
                
                prevPageBtn.disabled = currentPage === 1;
                nextPageBtn.disabled = currentPage === totalPages || totalPages === 0;
            }

            // Original parseRules function from version 13
            function parseRules(regolaColumn = 'REGOLA') {
                addDebugMessage("Inizio analisi delle regole...");
                ruleFields = {};
                
                // Find the correct column name (case insensitive)
                const actualColumn = headers.find(h => h.toLowerCase() === regolaColumn.toLowerCase()) || regolaColumn;
                
                // Process each row's REGOLA column
                let ruleCount = 0;
                let fieldCount = 0;
                let patternFound = 0;
                
                csvData.forEach((row, index) => {
                    const ruleText = row[actualColumn];
                    if (!ruleText) return;
                    
                    ruleCount++;
                    if (ruleCount <= 5) {
                        addDebugMessage(`Analisi regola #${index+1}: "${ruleText}"`);
                    }
                    
                    // First, handle square brackets by removing them for parsing
                    let cleanRuleText = ruleText;
                    const hasBrackets = ruleText.includes('[') && ruleText.includes(']');
                    
                    if (hasBrackets) {
                        cleanRuleText = ruleText.replace(/[\[\]]/g, '');
                        if (ruleCount <= 5) {
                            addDebugMessage(`  Rimosse parentesi quadre per l'analisi: "${cleanRuleText}"`);
                        }
                    }
                    
                    // Try to find field=value patterns with flexible spacing around =
                    const fieldRegex = /(\w+)\s*=\s*([^=]+?)(?=\s+\w+\s*=|$)/g;
                    let match;
                    let foundInThisRule = false;
                    
                    while ((match = fieldRegex.exec(cleanRuleText)) !== null) {
                        foundInThisRule = true;
                        patternFound++;
                        
                        const field = match[1].trim();
                        const valuesPart = match[2].trim();
                        
                        if (ruleCount <= 5) {
                            addDebugMessage(`  Campo trovato: "${field}" con espressione: "${valuesPart}"`);
                        }
                        
                        // Initialize field if not exists
                        if (!ruleFields[field]) {
                            ruleFields[field] = new Set();
                            fieldCount++;
                        }
                        
                        // Extract values, properly handling logical operators and parentheses
                        extractValues(field, valuesPart, ruleCount);
                    }
                    
                    if (!foundInThisRule && ruleCount <= 10) {
                        addDebugMessage(`  Nessun pattern campo=valore trovato nella regola #${index+1}`, "warning");
                    }
                });
                
                // Convert Sets to Arrays
                Object.keys(ruleFields).forEach(field => {
                    ruleFields[field] = Array.from(ruleFields[field]).sort();
                });
                
                addDebugMessage(`Analisi completata. Trovati ${fieldCount} campi in ${ruleCount} regole. Pattern riconosciuti: ${patternFound}`);
                addDebugMessage("Campi e valori estratti:");
                Object.keys(ruleFields).forEach(field => {
                    addDebugMessage(`  ${field}: ${ruleFields[field].join(', ')}`);
                });
                
                updateDebugPanel();
            }

            function extractValues(field, valuesPart, ruleCount) {
                // Remove logical operators (AND, OR) only at the end - they separate different field=value pairs
                let cleanValues = valuesPart.replace(/\s+(AND|OR)\s*$/i, '').trim();
                
                if (ruleCount <= 5) {
                    addDebugMessage(`    Elaborazione valori per ${field}: "${cleanValues}"`);
                }
                
                // Handle parentheses for multiple values
                if (cleanValues.startsWith('(')) {
                    // Find the matching closing parenthesis
                    let parenCount = 0;
                    let endIndex = -1;
                    
                    for (let i = 0; i < cleanValues.length; i++) {
                        if (cleanValues[i] === '(') parenCount++;
                        if (cleanValues[i] === ')') {
                            parenCount--;
                            if (parenCount === 0) {
                                endIndex = i;
                                break;
                            }
                        }
                    }
                    
                    if (endIndex !== -1) {
                        // Extract only the content within the first set of parentheses
                        const innerValues = cleanValues.slice(1, endIndex);
                        const values = innerValues.split(',').map(v => v.trim()).filter(v => v);
                        
                        values.forEach(value => {
                            ruleFields[field].add(value);
                            if (ruleCount <= 5) {
                                addDebugMessage(`      Aggiunto valore: "${value}"`);
                            }
                        });
                        
                        // Check if there's more content after the closing parenthesis (like "and DOOR_VOLTAGE (80VDC")
                        const remainingText = cleanValues.slice(endIndex + 1).trim();
                        if (remainingText) {
                            const nextFieldMatch = remainingText.match(/^\s*and\s+(\w+)\s*\(([^)]+)\)/i);
                            if (nextFieldMatch) {
                                const nextField = nextFieldMatch[1].trim();
                                const nextValue = nextFieldMatch[2].trim();
                                if (!ruleFields[nextField]) {
                                    ruleFields[nextField] = new Set();
                                }
                                ruleFields[nextField].add(nextValue);
                                if (ruleCount <= 5) {
                                    addDebugMessage(`      Trovato campo aggiuntivo: "${nextField}" con valore: "${nextValue}"`);
                                }
                            }
                        }
                    } else {
                        // Malformed parentheses, treat as single value
                        ruleFields[field].add(cleanValues);
                        if (ruleCount <= 5) {
                            addDebugMessage(`      Aggiunto valore con parentesi malformate: "${cleanValues}"`);
                        }
                    }
                } else {
                    // Single value without parentheses
                    ruleFields[field].add(cleanValues);
                    if (ruleCount <= 5) {
                        addDebugMessage(`      Aggiunto valore singolo: "${cleanValues}"`);
                    }
                }
            }

            function createFilters() {
                if (Object.keys(ruleFields).length === 0) {
                    addDebugMessage("Nessun campo trovato. Esegui prima l'analisi delle regole.", "warning");
                    return;
                }

                const container = document.getElementById('filter-container');
                container.innerHTML = '';

                // Calculate available values based on current filters
                updateAvailableFilters();

                Object.keys(ruleFields).forEach(field => {
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'bg-gray-50 p-4 rounded-lg border';
                    
                    const fieldTitle = document.createElement('h4');
                    fieldTitle.className = 'font-semibold text-gray-800 mb-3';
                    fieldTitle.textContent = field;
                    fieldDiv.appendChild(fieldTitle);
                    
                    const valuesDiv = document.createElement('div');
                    valuesDiv.className = 'flex flex-wrap gap-2';
                    
                    const availableValues = availableFilters[field] || ruleFields[field];
                    const allValues = ruleFields[field];
                    
                    allValues.forEach(value => {
                        const button = document.createElement('button');
                        const isSelected = activeFilters[field] === value;
                        const isAvailable = availableValues.includes(value);
                        
                        if (isSelected) {
                            button.className = 'px-3 py-1 bg-indigo-600 text-white rounded-full text-sm font-medium';
                        } else if (isAvailable) {
                            button.className = 'px-3 py-1 bg-white text-gray-700 border border-gray-300 rounded-full text-sm hover:bg-gray-50 cursor-pointer';
                        } else {
                            button.className = 'px-3 py-1 bg-gray-200 text-gray-400 border border-gray-200 rounded-full text-sm cursor-not-allowed opacity-50';
                            button.disabled = true;
                        }
                        
                        button.textContent = value;
                        
                        if (!button.disabled) {
                            button.addEventListener('click', () => {
                                if (activeFilters[field] === value) {
                                    // Deselect
                                    delete activeFilters[field];
                                } else {
                                    // Select
                                    activeFilters[field] = value;
                                }
                                
                                applyFilters();
                                createFilters(); // Recreate to update available options
                            });
                        }
                        
                        valuesDiv.appendChild(button);
                    });
                    
                    fieldDiv.appendChild(valuesDiv);
                    container.appendChild(fieldDiv);
                });
            }

            function updateAvailableFilters() {
                availableFilters = {};
                
                // Get all rows that match current filters (excluding the field we're calculating for)
                Object.keys(ruleFields).forEach(field => {
                    availableFilters[field] = new Set();
                    
                    csvData.forEach(row => {
                        const ruleText = row[headers.find(h => h.toLowerCase() === 'regola')] || '';
                        
                        // Check if this row matches all other active filters
                        const otherFilters = { ...activeFilters };
                        delete otherFilters[field];
                        
                        if (matchesFilters(ruleText, otherFilters)) {
                            // Extract values for this field from this rule
                            const fieldValues = extractFieldValuesFromRule(ruleText, field);
                            fieldValues.forEach(value => availableFilters[field].add(value));
                        }
                    });
                    
                    availableFilters[field] = Array.from(availableFilters[field]).sort();
                });
            }

            function extractFieldValuesFromRule(ruleText, targetField) {
                const values = [];
                let cleanRuleText = ruleText.replace(/[\[\]]/g, '');
                
                const fieldRegex = /(\w+)\s*=\s*([^=]+?)(?=\s+\w+\s*=|$)/g;
                let match;
                
                while ((match = fieldRegex.exec(cleanRuleText)) !== null) {
                    const field = match[1].trim();
                    const valuesPart = match[2].trim();
                    
                    if (field === targetField) {
                        // Remove logical operators (AND, OR) only at the end
                        let cleanValues = valuesPart.replace(/\s+(AND|OR)\s*$/i, '').trim();
                        
                        if (cleanValues.startsWith('(')) {
                            // Find the matching closing parenthesis
                            let parenCount = 0;
                            let endIndex = -1;
                            
                            for (let i = 0; i < cleanValues.length; i++) {
                                if (cleanValues[i] === '(') parenCount++;
                                if (cleanValues[i] === ')') {
                                    parenCount--;
                                    if (parenCount === 0) {
                                        endIndex = i;
                                        break;
                                    }
                                }
                            }
                            
                            if (endIndex !== -1) {
                                // Extract only the content within the first set of parentheses
                                const innerValues = cleanValues.slice(1, endIndex);
                                const multiValues = innerValues.split(',').map(v => v.trim()).filter(v => v);
                                values.push(...multiValues);
                            }
                        } else {
                            values.push(cleanValues);
                        }
                    }
                }
                
                // Also check for fields that appear after "and" in truncated patterns
                const truncatedFieldRegex = /\)\s+and\s+(\w+)\s*\(([^)]+)\)/gi;
                let truncatedMatch;
                while ((truncatedMatch = truncatedFieldRegex.exec(cleanRuleText)) !== null) {
                    const field = truncatedMatch[1].trim();
                    const value = truncatedMatch[2].trim();
                    
                    if (field === targetField) {
                        values.push(value);
                    }
                }
                
                return values;
            }

            function matchesFilters(ruleText, filters) {
                if (Object.keys(filters).length === 0) return true;
                
                let cleanRule = ruleText.replace(/[\[\]]/g, '').trim();
                
                // For each active filter, check if the rule contains a matching condition
                for (const [field, value] of Object.entries(filters)) {
                    let hasMatch = false;
                    
                    // First check normal field=value patterns
                    const fieldRegex = new RegExp(`${field}\\s*=\\s*([^=]+?)(?=\\s+\\w+\\s*=|$)`, 'g');
                    let match = fieldRegex.exec(cleanRule);
                    
                    if (match) {
                        // Remove logical operators (AND, OR) only at the end
                        const valuesPart = match[1].trim().replace(/\s+(AND|OR)\s*$/i, '').trim();
                        
                        if (valuesPart.startsWith('(')) {
                            // Find the matching closing parenthesis
                            let parenCount = 0;
                            let endIndex = -1;
                            
                            for (let i = 0; i < valuesPart.length; i++) {
                                if (valuesPart[i] === '(') parenCount++;
                                if (valuesPart[i] === ')') {
                                    parenCount--;
                                    if (parenCount === 0) {
                                        endIndex = i;
                                        break;
                                    }
                                }
                            }
                            
                            if (endIndex !== -1) {
                                // Extract only the content within the first set of parentheses
                                const innerValues = valuesPart.slice(1, endIndex);
                                const multiValues = innerValues.split(',').map(v => v.trim()).filter(v => v);
                                hasMatch = multiValues.includes(value);
                            }
                        } else {
                            hasMatch = valuesPart === value;
                        }
                    }
                    
                    // Also check for fields that appear after "and" in truncated patterns
                    if (!hasMatch) {
                        const truncatedFieldRegex = new RegExp(`\\)\\s+and\\s+${field}\\s*\\(([^)]+)\\)`, 'gi');
                        let truncatedMatch = truncatedFieldRegex.exec(cleanRule);
                        if (truncatedMatch) {
                            const truncatedValue = truncatedMatch[1].trim();
                            hasMatch = truncatedValue === value;
                        }
                    }
                    
                    if (!hasMatch) return false;
                }
                
                return true;
            }

            function applyFilters() {
                if (Object.keys(activeFilters).length === 0) {
                    filteredData = [...csvData];
                } else {
                    const regolaColumn = headers.find(h => h.toLowerCase() === 'regola');
                    filteredData = csvData.filter(row => {
                        const ruleText = row[regolaColumn] || '';
                        return matchesFilters(ruleText, activeFilters);
                    });
                }
                
                currentPage = 1;
                displayTable();
                updateRowCount();
                updatePagination();
                
                addDebugMessage(`Filtri applicati. ${filteredData.length} righe corrispondenti.`);
            }
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'979dafbee0bc5278',t:'MTc1Njk5MTAwMS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
